focus: true
tests:
  - desc: '5. Functions'
  - desc: '5.1 Existence'
  - desc: '5.1.1. empty() : boolean'
# Returns true if the input collection is empty ({ }) and false otherwise.

  - desc: '** empty coll'
    expression: Functions.attrempty.empty()
    result: [true]

  - desc: '** not empty coll'
    expression: Functions.attrsingle.empty()
    result: [false]

  - desc: '** empty nothing'
    expression: Functions.nothing.empty()
    result: [true]

  - desc: '5.1.2. not() : boolean'
# Returns true if the input collection evaluates to
# false, and false if it evaluates to true. Otherwise, the result is empty ({
# }):

#  	not
# true

# false

# false

# true

# empty ({ })

# empty ({ })

  - desc: '** not true is false'
    expression: Functions.attrtrue.not()
    result: [false]

  - desc: '** not false is true'
    expression: Functions.attrfalse.not()
    result: [true]

  - desc: '** true with double not is true'
    expression: Functions.attrtrue.not().not()
    result: [true]

  - desc: '** empty coll with not() is empty coll'
    expression: Functions.attrempty.not()
    result: []

  - desc: '** not empty, non-boolean coll with not() is empty'
    expression: Functions.attrdouble.not()
    result: []

  - desc: '** multi-valued boolean coll with not() is empty'
    expression: Functions.attrdouble.not()
    result: []

  - desc: '** not nothing is empty coll'
    expression: Functions.nothing.not()
    result: []


  - desc: '5.1.3. exists([criteria : expression]) : boolean'
#  Returns true if the collection has any elements, and false otherwise. This is the opposite of
# empty(), and as such is a shorthand for empty().not(). If the input collection
# is empty ({ }), the result is false.

  - desc: '** exists for not empty coll should return true'
    expression: Functions.coll1.exists()
    result: [true]


  - desc: '** exists for empty coll should return false'
    expression: Functions.attrempty.exists()
    result: [false]

  - desc: '** exists for undefined coll should return false'
    expression: Functions.nothing.exists()
    result: [false]

# The operator can also take an optional criteria to be applied to the collection prior to the determination of the exists. In this case, the operation is shorthand for where(criteria).exists().

  - desc: '** exists with criteria should work'
    expression: Functions.coll1.coll2.attr.exists($this > 0)
    result: [true]

  - desc: '** exists with criteria should work for empty filtered coll'
    expression: Functions.coll1.coll2.attr.exists($this < 0)
    result: [false]

  - desc: '** exists with criteria should work for not exists coll '
    expression: Functions.nothing.attr.exists($this < 0)
    result: [false]


  - desc: '5.1.4. all(criteria : expression) : boolean'
# Returns true if for every element in the input collection, criteria evaluates to true. Otherwise, the result is
# false. If the input collection is empty ({ }), the result is true.

  - desc: '** all for empty coll is true'
    expression: Functions.attrempty.all($this > 0)
    result: [true]

  - desc: '** all for non-exists coll is true'
    expression: Functions.nothing.all($this > 0)
    result: [true]

  - desc: '** all for evaluations is true'
    expression: Functions.coll1.coll2.attr.all($this > 0)
    result: [true]


  - desc: '** not all evaluations is true'
    expression: Functions.coll1.coll2.attr.all($this = 5)
    result: [false]


  - desc: '5.1.5. allTrue() : boolean'
# Takes a collection of boolean values and returns
# true if all the items are true. If any items are false, the result is false.
# If the input is empty ({ }), the result is true.

  - desc: '** allTrue for empty coll is true'
    expression: Functions.attrempty.allTrue()
    result: [true]

  - desc: '** allTrue for coll with all true items is true'
    expression: Functions.coll1.colltrue.attr.allTrue()
    result: [true]

  - desc: '** allTrue for coll with false value'
    expression: Functions.coll1.collwithfalse.attr.allTrue()
    result: [false]

  - desc: '** allTrue for non exists coll is true'
    expression: Functions.nothing.allTrue()
    result: [true]


  - desc: '5.1.6. anyTrue() : boolean'
# Takes a collection of boolean values and returns
# true if any of the items are true. If all the items are false, or if the input
# is empty ({ }), the result is false.

  - desc: '** anyTrue for empty coll is false'
    expression: Functions.attrempty.anyTrue()
    result: [false]

  - desc: '** anyTrue for non-exists coll is false'
    expression: Functions.nothing.anyTrue()
    result: [false]

  - desc: '** anyTrue for coll with true value'
    expression: Functions.coll1.collwithfalse.attr.anyTrue()
    result: [true]

  - desc: '** anyTrue for coll with all false values'
    expression: Functions.coll1.collfalse.attr.anyTrue()
    result: [false]


  - desc: '5.1.7. allFalse() : boolean'
# Takes a collection of boolean values and returns
# true if all the items are false. If any items are true, the result is false.
# If the input is empty ({ }), the result is true.

  - desc: '** allFalse for empty coll is true'
    expression: Functions.attrempty.allFalse()
    result: [true]

  - desc: '** allFalse for non-exists coll is true'
    expression: Functions.nothing.allFalse()
    result: [true]

  - desc: '** allFalse for coll with all false items is true'
    expression: Functions.coll1.collfalse.attr.allFalse()
    result: [true]

  - desc: '** allFalse for coll with true value'
    expression: Functions.coll1.collwithfalse.attr.allFalse()
    result: [false]


  - desc: '5.1.8. anyFalse() : boolean'
# Takes a collection of boolean values and returns
# true if any of the items are false. If all the items are true, or if the input
# is empty ({ }), the result is false.

  - desc: '** anyFalse for empty coll is false'
    expression: Functions.attrempty.anyFalse()
    result: [false]

  - desc: '** anyFalse for non-exists coll is false'
    expression: Functions.nothing.anyFalse()
    result: [false]

  - desc: '** anyFalse for coll with false value'
    expression: Functions.coll1.collwithfalse.attr.anyFalse()
    result: [true]

  - desc: '** anyFalse for coll with all true values'
    expression: Functions.coll1.colltrue.attr.anyFalse()
    result: [false]

  - desc: 'TODO 5.1.5 - 5.1.8 add test for non-boolean values'


  - desc: '5.1.9. subsetOf(other : collection) : boolean'
# Returns true if all items in the
# input collection are members of the collection passed as the other argument.
# Membership is determined using the equals (=) operation (see below).

# Conceptually, this function is evaluated by testing each element in the input
# collection for membership in the other collection, with a default of true.
# This means that if the input collection is empty ({ }), the result is true,
# otherwise if the other collection is empty ({ }), the result is false.

  - desc: '** if input coll is empty - result of subset is true'
    expression: Functions.attrempty.subsetOf(Functions.attrdouble)
    result: [true]

  - desc: '** if argument coll is empty - result of subset is false'
    expression: Functions.attrdouble.subsetOf(Functions.attrempty)
    result: [false]

  - desc: '** if argument coll isnt exists -  result of subset is false'
    expression: Functions.attrdouble.subsetOf(Functions.attrempty)
    result: [false]

  - desc: '** if input coll is subset of argument coll'
    expression: Functions.attrdouble.subsetOf(Functions.coll1[0].coll2.attr)
    result: [true]

  - desc: '** if input coll isnt subset of argument coll'
    expression: Functions.coll1[0].coll2.attr.subsetOf(Functions.attrdouble)
    result: [false]

  - desc: '** 5.1.10. supersetOf(other : collection) : boolean'
# Returns true if all items in the collection passed as the other argument are members of the input
# collection. Membership is determined using the equals (=) operation (see
# below).

# Conceptually, this function is evaluated by testing each element in the other
# collection for membership in the input collection, with a default of false.
# This means that if the input collection is empty ({ }), the result is false,
# otherwise if the other collection is empty ({ }), the result is true.

  - desc: '** if argumet coll is empty - result of superset is true'
    expression: Functions.attrdouble.supersetOf(Functions.attrempty)
    result: [true]

  - desc: '** if input coll is empty - result of superset is false'
    expression: Functions.attrempty.supersetOf(Functions.attrdouble)
    result: [false]

  - desc: '** if input coll isnt exists  - result of superset is false'
    expression: Functions.attrempty.supersetOf(Functions.nothing)
    result: [false]

  - desc: '** if argument coll is superset of input coll result is true'
    expression: Functions.coll1[0].coll2.attr.supersetOf(Functions.attrdouble)
    result: [true]

  - desc: '** if argument coll isnt superset of input coll result is false'
    expression: Functions.attrdouble.supersetOf(Functions.coll1[0].coll2.attr)
    result: [false]


  - desc: '5.1.11. isDistinct() : boolean'
# Returns true if all the items in the input
# collection are distinct. To determine whether two items are distinct, the
# equals (=) operator is used, as defined below.

# Conceptually, this function is shorthand for a comparison of the count() of
# the input collection against the count() of the distinct() of the input
# collection:

# X.count() = X.distinct().count() This means that if the input collection is
# empty ({ }), the result is true.

  - desc: '** isDistinct of empty input coll is true'
    expression: Functions.attrempty.isDistinct()
    result: [true]

  - desc: '** isDistinct of non-exists coll is true'
    expression: Functions.nothing.isDistinct()
    result: [true]

  - desc: '** isDistinct of distinct coll'
    expression: Functions.coll1[0].coll2.attr.isDistinct()
    result: [true]

  - desc: '** isDistinct of coll with different values'
    expression: Functions.coll1[2].collwithfalse.attr.isDistinct()
    result: [true]


  - desc: '5.1.12. distinct() : collection'
# Returns a collection containing only the
# unique items in the input collection. To determine whether two items are the
# same, the equals (=) operator is used, as defined below.

# If the input collection is empty ({ }), the result is empty.

  - desc: '** distinct of empty coll is empty'
    expression: Functions.attrempty.distinct()
    result: []

  - desc: '** distinct of non-exists coll is empty'
    expression: Functions.nothing.distinct()
    result: []

  - desc: '** distinct of coll with same values'
    expression: Functions.coll1[2].colltrue.attr.distinct()
    result: [true]

  - desc: '** distinct of coll with different values'
    expression: Functions.coll1[0].coll2.attr.distinct()
    result: [1, 2, 3]


  - desc: '5.1.13. count() : integer'
# Returns a collection with a single value which is
# the integer count of the number of items in the input collection. Returns 0
# when the input collection is empty.

  - desc: '** count'
    expression: Functions.coll1.count()
    result: [6]

  - desc: '** nested count'
    expression: Functions.coll1.coll2.count()
    result: [5]

  - desc: '** nested count (alternative)'
    expression: Functions.coll1[0].coll2.count()
    result: [3]

  - desc: '** 0 if nothing'
    expression: Functions.ups.count()
    result: [0]


  - desc: '5.2. Filtering and projection'
  - desc: '5.2.1. where(criteria : expression) : collection'
# Returns a collection containing only those elements in the input collection for which the stated criteria expression evaluates to true. Elements for which the expression evaluates to false or empty ({ }) are not included in the result.

  - desc: '** filter coll of numbers'
    expression: Functions.coll1.coll2.attr.where($this > 2)
    result: [3, 4, 5]

  - desc: '** filter coll with empty coll result'
    expression: Functions.coll1.coll2.attr.where($this = 0)
    result: []

# If the input collection is emtpy ({ }), the result is empty.

  - desc: '** filter empty coll'
    expression: Functions.attrempty.where($this > 0)
    result: []

  - desc: '** filter non-exists coll'
    expression: Functions.nothing.where($this < 0)
    result: []

  - desc: '5.2.2. select(projection: expression) : collection'
# Evaluates the projection expression for each item in the input collection. The result of each evaluation is added to the output collection. If the evaluation results in a collection with multiple items, all items are added to the output collection (collections resulting from evaluation of projection are flattened). This means that if the evaluation for an element results in the empty collection ({ }), no element is added to the result, and that if the input collection is empty ({ }), the result is empty as well.

  - desc: '** simple select'
    expression: Functions.coll1.coll2.select(attr)
    result: [1, 2, 3, 4, 5]

  - desc: '** select 2'
    expression: Functions.coll1.select(colltrue | collfalse).attr
    result: [true, true, true, false, false]

  - desc: '** select 3'
    expression: Functions.coll1.select(colltrue.attr | collfalse.attr)
    result: [true, true, true, false, false]

  - desc: '** select on empty coll is empty'
    expression: Functions.attrempty.select(nothing)
    result: []

  - desc: '** select 4'
  - desc: 'TODO - is valid case? how it works?'
    expression: Functions.coll1.select(colltrue.attr.allTrue() | collfalse.attr.allTrue())
    result: [true]


  - desc: '5.2.3. repeat(projection: expression) : collection'
# A version of select that will repeat the projection and add it to the output collection, as long as the projection yields new items (as determined by the equals (=) operator).

# This operation can be used to traverse a tree and selecting only specific children:

# ValueSet.expansion.repeat(contains)
# Will repeat finding children called contains, until no new nodes are found.

# Questionnaire.repeat(group | question).question
# Will repeat finding children called group or question, until no new nodes are found.

# Note that this is slightly different from:

# Questionnaire.descendants().select(group | question)
# which would find any descendants called group or question, not just the ones nested inside other group or question elements.
  - desc: '* traverse tree'
  - desc: '** find all attrs'
    expression: Functions.repeat(attr).count()
    result: [12]

  - desc: '** find all 2 and 3 values'
    expression: Functions.repeat(2 | 3).count();
    result: [4]

  - desc: 'TODO/FIXME infinite loop test:'
    expression: true
    result: false
  # - desc: '** find all true values in nested coll'
  #   expression: Functions.coll1.colltrue.repeat(true)
  #   result: [true, true, true]

  - desc: '** find non-exists value'
    expression: Functions.coll1.repeat(nothing)
    result: []



  - desc: '5.2.4. ofType(type : identifier) : collection'
# Returns a collection that contains all items in the input collection that are of the given type or a subclass thereof. If the input collection is empty ({ }), the result is empty.

  - desc: '** select boolean values'
    expression: Functions.coll1.mixed.attr(boolean)
    result: [true, false]

  - desc: '** select boolean values which non-exists in coll'
    expression: Functions.coll1.coll2.attr.ofType(boolean)
    result: []

  - desc: '** select boolean values in non-exists coll'
    expression: Functions.coll1.nothing.ofType(boolean)
    result: []

  - desc: '** select boolean values empty coll'
    expression: Functions.attrempty.ofType(boolean)
    result: []

  - desc: '** select string values'
    expression: Functions.coll1.mixed.attr(string)
    result: ['test string']

  - desc: '** select integer values'
    expression: Functions.coll1.mixed.attr(integer)
    result: [999]

  - desc: '** select decimal values'
    expression: Functions.coll1.mixed.attr(decimal)
    result: [3.14159]

  - desc: '** select dateTime values'
    expression: Functions.coll1.mixed.attr(dateTime)
    result: ['@2015-02-04T14:34:28Z']

  - desc: '** select time values'
    expression: Functions.coll1.mixed.attr(time)
    result: ['@T14:34:28+09:00']

  - desc: '** select quantity values'
    expression: Functions.coll1.mixed.attr(quantity)
    result: [4 days]



  - desc: '5.3. Subsetting 5.3.1. [ index : integer ] : collection'
# The indexer operation
# returns a collection with only the index-th item (0-based index). If the input
# collection is empty ({ }), or the index lies outside the boundaries of the
# input collection, an empty collection is returned.

# Example:

# Patient.name[0]

  - desc: '** [index]'
    expression: Functions.coll1[1].coll2[0].attr
    result: [4]

  - desc: '** [big index]'
    expression: Functions.coll1[100].coll2[0].attr
    result: []
 
  - desc: '5.3.2. single() : collection'
# Will return the single item in the input if there
# is just one item. If the input collection is empty ({ }), the result is empty.
# If there are multiple items, an error is signaled to the evaluation
# environment. This operation is useful for ensuring that an error is returned
# if an assumption about cardinality is violated at run-time.
  - desc: '** single'
    expression: Functions.attrsingle.single()
    result: [1]

  - desc: '** single on nothing'
    expression: Functions.ups.single()
    result: []

  - desc: '** single on empty'
    expression: Functions.attrempty.single()
    result: []

  - desc: '** single on many'
    expression: Functions.attrdouble.single()
    result:
      $status: error
      $error: Expected single
 
  - desc: '5.3.3. first() : collection'
# Returns a collection containing only the first
# item in the input collection. This function is equivalent to item(0), so it
# will return an empty collection if the input collection has no items.
  - desc: '** first'
    expression: Functions.attrdouble.first()
    result: [1]

  - desc: '** first nothing'
    expression: Functions.nothing.first()
    result: []

  - desc: '5.3.4. last() : collection'
# Returns a collection containing only the last item
# in the input collection. Will return an empty collection if the input
# collection has no items.

  - desc: '** last'
    expression: Functions.attrdouble.last()
    result: [2]

  - desc: '** last (alternative)'
    expression: Functions.attrsingle.last()
    result: [1]

  - desc: '** last on empty'
    expression: Functions.attrempty.last()
    result: []

  - desc: '** last nothing'
    expression: Functions.nothing.last()
    result: []

  - desc: '5.3.5. tail() : collection'
# Returns a collection containing all but the first
# item in the input collection. Will return an empty collection if the input
# collection has no items, or only one item.

  - desc: '** tail'
    expression: Functions.attrdouble.tail()
    result: [ 2 ]

  - desc: '** tail on one'
    expression: Functions.attrsingle.tail()
    result:  [ ]

  - desc: '** tail on empty'
    expression: Functions.attrempty.tail()
    result: []

  - desc: '** tail nothing'
    expression: Functions.nothing.tail()
    result: []

  - desc: '** tail (alternative)'
    expression: Functions.coll1.coll2.attr.tail()
    result: [2, 3, 4, 5]


  - desc: '5.3.6. skip(num : integer) : collection'
# Returns a collection containing all
# but the first num items in the input collection. Will return an empty
# collection if there are no items remaining after the indicated number of items
# have been skipped, or if the input collection is empty. If num is less than or
# equal to zero, the input collection is simply returned.
  - desc: '** skip'
    expression: Functions.attrdouble.skip(1)
    result: [2]

  - desc: '** skip 2'
    expression: Functions.attrsingle.skip(1)
    result: []

  - desc: '** skip 3'
    expression: Functions.coll1.coll2.attr.skip(3)
    result: [4, 5]

  - desc: '** skip 4'
    expression: Functions.coll1.coll2.attr.skip(4)
    result: [5]

  - desc: '** skip 5'
    expression: Functions.coll1.coll2.attr.skip(5)
    result: []

  - desc: '** skip 6'
    expression: Functions.coll1.coll2.attr.skip(6)
    result: []


  - desc: '5.3.7. take(num : integer) : collection'
# Returns a collection containing the
# first num items in the input collection, or less if there are less than num
# items. If num is less than or equal to 0, or if the input collection is empty
# ({ }), take returns an empty collection.

  - desc: '** take'
    expression: Functions.attrdouble.take(1)
    result: [ 1 ]

  - desc: '** take 2'
    expression: Functions.attrdouble.take(2)
    result: [ 1, 2 ]

  - desc: '** take more then has'
    expression: Functions.attrsingle.take(2)
    result:  [ 1 ]

  - desc: '** take on empty'
    expression: Functions.attrempty.take(1)
    result: []

  - desc: '** take nothing'
    expression: Functions.nothing.take(2)
    result: []

  - desc: '** take 3'
    expression: Functions.coll1.coll2.attr.take(3)
    result: [1, 2, 3]

  - desc: '** take 4'
    expression: Functions.coll1.coll2.attr.take(4)
    result: [1, 2, 3, 4]

  - desc: '** take 5'
    expression: Functions.coll1.coll2.attr.take(5)
    result: [1, 2, 3, 4, 5]

# 5.4. Combining
# 5.4.1. | (union collections)
# Merge the two collections into a single collection, eliminating any duplicate values (using equals (=)) to determine equality). Unioning an empty collection to a non-empty collection will return the non-empty collection with duplicates eliminated. There is no expectation of order in the resulting collection.

# 5.4.2. combine(other : collection) : collection
# Merge the input and other collections into a single collection without eliminating duplicate values. Combining an empty collection with a non-empty collection will return the non-empty collection. There is no expectation of order in the resulting collection.


  - desc: '5.5.1. iif(criterium: expression, true-result: collection [, otherwise-result:
 collection]) : collection'
# If criterium is true, the function returns the value
# of true-result parameter.

# If criterium is false or an empty collection, the function returns
# otherwise-result, unless the optional otherwise-expression is not given, in
# which case the function returns an empty collection.

  - desc: '** boolean - true'
    expression: 'true'
    result: [true]

  - desc: '** boolean - false'
    expression: 'false'
    result: [false]

  - desc: '** iif'
    expression: Functions.iif(true, 'a', 'b')
    result: ['a']

  - desc: '** iif 2'
    expression: Functions.iif(false, 'a', 'b')
    result: ['b']

  - desc: '** iif 3'
    expression: Functions.iif(coll1[0].coll2[0].attr = 1, coll1[0].coll2[0].attr, coll1[0].coll2[1].attr)
    result: [1]


subject:
  resourceType: Functions
  attrempty: []
  attrtrue: true
  attrfalse: false
  attrsingle:
    - 1
  attrdouble:
    - 1
    - 2
  attrobject:
    a: 1
    b: 2
  coll1:
    - coll2:
        - attr: 1
        - attr: 2
        - attr: 3
    - coll2:
        - attr: 4
        - attr: 5
    - colltrue:
        - attr: true
        - attr: true
        - attr: true
    - collwithfalse:
        - attr: false
        - attr: true
    - collfalse:
        - attr: false
        - attr: false
    - mixed:
        - attr: true
        - attr: false
        - attr: 'test string'
        - attr: 999
        - attr: 3.14159
        - attr: '@2015-02-04T14:34:28Z'
        - attr: '@T14:34:28+09:00'
        - attr: 4 days
